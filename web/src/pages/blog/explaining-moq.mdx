# Explaining MoQ
wtf is moq

## Layers
We start our journey by slicing an onion.
The most critical, and least documented, thing to understand is the layering.

From bottom to top:
- QUIC: The network layer
- web-transport: 
- moq-transfork
- moq-karp

This guide will also help explain the IETF drafts because while I forked them, the high level concepts are still very similar.
Just gotta rename a few things:

- transport -> transfork
- warp -> karp

Yes I only changed a few letters; your mental model will thank me.

## QUIC
QUIC is that new protocol that powers HTTP/3.
It's intended to be an generic improvement over TCP

With TCP, an application has to decide how many connections to open, each involving an expensive TCP/TLS handshake.
If you use multiple connections (like HTTP/1), they fight for bandwidth and you still can't drop messages without closing the connection.
If you use a single connection (like HTTP/2), messages are delivered in order and cannot be dropped, causing head-of-line blocking.

QUIC fixes this dilemma by providing a single connection with multiple streams.
These streams can be created, delivered, and closed in parallel with minimal overhead.
And crucially for MoQ, streams can be *prioritized* by the QUIC library so the most important data is transmitted (although not necessarily received) first.

Note that QUIC uses UDP under the hood.
This is frankly a necessity, as a new protocol over IP is difficult to support, as evidenced by SCTP.
But it does cause some firewall and performance problems because the Internet is (currently) optimized for TCP.

There's a LOT of little features so check out my QUIC POWERS blog post for more.

## WebTransport 
I just said QUIC was created for HTTP/3, what gives?

Well you can totally use HTTP/3 to implement something like MoQ.
However, the HTTP semantics add more hoops to jump through, for example long-polling to emulate a live stream.
Somebody else can do Media over HTTP/3.

What I am interested in is WebTransport.
It's a browser API that exposes QUIC streams to a web application, similar to how WebSockets exposes TCP.
There's not much else to say, it's basically the same thing as QUIC.

...except that the underlying implementation is gross.
WebTransport shares a QUIC connection with HTTP/3 and potentially other WebTransport sessions.
This *pooling* feature is responsible for a ton of headaches but it's too late to argue against it any louder.
There's also a TCP fallback in development (Http2Transport) but I would use WebSockets instead.

Just use an exising WebTransport library (like mine!) and pretend that it's identical to QUIC.

## MoqTransfork
Finally, the good stuff.

Remember the part where I said where don't want to use HTTP/3?
It was literally in the previous section.
Well, we do want some of the nice HTTP properties so it's time to make our own.

One of the biggest headaches with WebRTC is the story around fan out.
A broadcaster could establish a connection to all N viewers, but sending N copies of the data quickly becomes a problem especially on slow networks.
Outside of 1:1 or niche peer-to-peer use-cases, WebRTC broadcasters instead connect to an SFU server and use the power of data centers to fan media out to all viewers.

The problem with this approach is that it's surprisingly custom.
There's no generic way for an application to signal *how* media should be forwarded, leading to divergent and usually proprietary SFU behavior.
A (good) SFU is also very media specific, often parsing the payload on a per-codec basis to detect things like keyframes.
All of this custom behavior deincentivises reuse and shrinks the available offerings.

MoqTransfork is an ambitious attempt to learn from the succesess of HTTP and the affirmationed failures of WebRTC.
But you know, for live content and not *hyper-text*.
